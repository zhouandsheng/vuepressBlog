(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{424:function(e,n,t){"use strict";t.r(n);var a=t(56),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue2面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2面试题"}},[e._v("#")]),e._v(" vue2面试题")]),e._v(" "),t("p",[t("strong",[e._v("1.vue2.x生命周期有哪些")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("beforeCreate\ncreated\nbeforemount\nmounted\nbeforeUpdate\nupdated\nbeforeDestroy\ndestroyed\n\n1.首次进入页面或者组价会执行哪些生命周期\n\n")])])]),t("p",[t("strong",[e._v("2.第一次进入组件或者页面，会执行哪些生命周期函数")])]),e._v(" "),t("p",[t("strong",[e._v("3.谈谈你对keep-alive的了解")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.是什么\n\tvue系统自带的一个组件，功能：用来缓存组件 提升性能\n\t\n\t比如进入详情页，每次都是相同的，就可以缓存起来，没必要再次请求\n\t\n")])])]),t("p",[t("strong",[e._v("4.v-if和v-show的区别")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("展现形式不同\nv-if 是创建一个dom节点\nv-show 是利用css  display:none 隐藏\n\n2.使用场景\n初次加载v-if比v-show好， 页面不会加载盒子\n频繁切换v-show 比v-if好，  创建和删除的开销太大\n\n\n\n")])])]),t("p",[t("strong",[e._v("5.v-if与v-for的优先级")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.v-for优先级高于v-if被解析\n2.如果同时出现每循环都会执行判断条件，是无法避免的，浪费性能\n3.解决办法：在外层嵌套<template></template>在这一层进行判断，内部在进行循环\n")])])]),t("p",[t("strong",[e._v("6.ref是什么")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("来获取dom节点\n\n")])])]),t("p",[t("strong",[e._v("7.nextTick是什么")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("获取更新后的dom的内容\n")])])]),t("p",[t("strong",[e._v("8.路由导航守卫有哪些")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("全局，路由独享，组件内\n1.全局\n\n")])])]),t("p",[e._v("​")]),e._v(" "),t("p",[t("strong",[e._v("9.vue中如何做样式穿透")])]),e._v(" "),t("p",[t("strong",[e._v("10.讲一下MVVM")])]),e._v(" "),t("p",[t("strong",[e._v("11.双向数据绑定原理")])]),e._v(" "),t("p",[t("strong",[e._v("12.什么是虚拟DOM")])]),e._v(" "),t("p",[t("strong",[e._v("13.diff算法")])]),e._v(" "),t("p",[t("strong",[e._v("14.vue组件传值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.父组件传子组件\n\tprops\t\n2.子组件传父组件\n  this.$emit()\n3.兄弟组传值\n\t通过中转 bus\n\tthis.$on()\n\tthis.$emit()\n\n")])])]),t("p",[t("strong",[e._v("15.介绍一下SPA以及SPA有什么缺点")])]),e._v(" "),t("p",[t("strong",[e._v("16.Vue双向绑定和表单绑定")])]),e._v(" "),t("p",[t("strong",[e._v("17.props和data优先级谁高")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("props > methods > data >computed > watch\n")])])]),t("p",[t("strong",[e._v("18.computed ,methods ,watch有什么区别")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.computed vs methods\ncomputed是有缓存的，methods没有缓存\n2.computed va watch\nwatch是监听到当前数据发生改变，才会执行\ncomputed 是监听某一个属性发生改变才会执行\n\n\n")])])]),t("p",[t("strong",[e._v("19.Vuex")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n主要包括以下几个模块：\n\nState：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\n\nGetter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。\n\nMutation：是唯一更改 store 中状态的方法，且必须是同步函数。\n\nAction：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\n\nModule：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n\n\n")])])]),t("p",[t("strong",[e._v("20.组件之间的通信")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。\n\n（1）props / $emit 适用 父子组件通信\n\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n\n（2）ref 与 children 适用 父子组件通信\n\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n\nchildren：访问父 / 子实例\n\n（3）EventBus （on） 适用于 父子、隔代、兄弟组件通信\n\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n\n（4）listeners 适用于 隔代组件通信\n\nattrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n\nlisteners" 传入内部组件\n\n（5）provide / inject 适用于 隔代组件通信\n\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n\n（6）Vuex 适用于 父子、隔代、兄弟组件通信\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n')])])]),t("p",[t("strong",[e._v("21.什么是MVVM")])]),e._v(" "),t("p",[e._v("Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表")]),e._v(" "),t("p",[e._v("MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/12842279-5af933c42fa81a9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp",alt:"img"}})]),e._v(" "),t("p",[e._v("图片")]),e._v(" "),t("p",[t("strong",[e._v("（1）View 层")])]),e._v(" "),t("p",[e._v("View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。")]),e._v(" "),t("p",[t("strong",[e._v("（2）Model 层")])]),e._v(" "),t("p",[e._v("Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。")]),e._v(" "),t("p",[t("strong",[e._v("（3）ViewModel 层")])]),e._v(" "),t("p",[e._v("ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。")]),e._v(" "),t("p",[e._v("需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。")]),e._v(" "),t("p",[e._v("MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。")]),e._v(" "),t("p",[e._v("这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。")]),e._v(" "),t("p",[e._v("我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：")]),e._v(" "),t("p",[t("strong",[e._v("（1）View 层")])]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("div id"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"app"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])]),t("p",[t("strong",[e._v("（2）ViewModel 层")])]),e._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")])]),e._v(" app "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token constructor-invocation class-name"}},[e._v("Vue")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n")])])]),t("p",[e._v("（3） Model 层")]),e._v(" "),t("div",{staticClass:"language-undefined extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{}\n")])])]),t("p",[t("strong",[e._v("21.vue项目进行优化")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.路由懒加载:使用时候会变成按需加载\nconst router = new VueRouter({\n\troutes:[\n\t\t{path:'/foo',component:()=>import('./Foo.vue')}\n\t]\n})\n2.keep-alive 缓存页面\n3.使用v-show复用修复DOM\n4.v-for与v-if避免同时使用\n5.长列表性能优化\n\t只显示，不发生任何变化，就不需要相应画\n\t大数据长列表，可采用虚拟滚动  <recycle-scroller> 只渲染显示范围的数据，用户滚动的时候更新后面的数据\n6.事件的销毁 定时器的清除\n7.图片懒加载  vue-lazyload \n8.第三方插件按需引入\n\t\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("（1）代码层面的优化\n\nv-if 和 v-show 区分使用场景\n\ncomputed 和 watch 区分使用场景\n\nv-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n\n长列表性能优化\n\n事件的销毁\n\n图片资源懒加载\n\n路由懒加载\n\n第三方插件的按需引入\n\n优化无限列表性能\n\n服务端渲染 SSR or 预渲染\n\n（2）Webpack 层面的优化\n\nWebpack 对图片进行压缩\n\n减少 ES6 转为 ES5 的冗余代码\n\n提取公共代码\n\n模板预编译\n\n提取组件的 CSS\n\n优化 SourceMap\n\n构建结果输出分析\n\nVue 项目的编译优化\n\n（3）基础的 Web 技术的优化\n\n开启 gzip 压缩\n\n浏览器缓存\n\nCDN 的使用\n\n使用 Chrome Performance 查找性能瓶颈\n\n29、对于即将到来的 vue3.0 特性你有什么了解的吗？\nVue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：\n\n（1）监测机制的改变\n\n3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n\n只能监测属性，不能监测对象\n\n检测属性的添加和删除；\n\n检测数组索引和长度的变更；\n\n支持 Map、Set、WeakMap 和 WeakSet。\n\n新的 observer 还提供了以下特性：\n\n用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。\n\n默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。\n\n更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。\n\n不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。\n\n更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。\n\n（2）模板\n\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n\n（3）对象式的组件声明方式\n\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n\n3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。\n\n此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。\n\n现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。\n\n（4）其它方面的更改\n\nvue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：\n\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n\n支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n\n基于 treeshaking 优化，提供了更多的内置功能。\n\n")])])]),t("p",[t("strong",[e._v("22.vue组件中的data为什么必须是个函数")])]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("Vue组件可能存在多个实例，如果使用对象形式定义data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("则会导致他们共用一个data对象，那么状态会变更\n将影响所有的组件实例，这时不合理，\n采用函数形式定义initData会将其作为工厂韩式返回全新的data\n有效的避免多个实例之间状态污染问题，Vue根实例创建不存在该限制，因为根实例只有一个\n")])])]),t("p",[t("strong",[e._v("22.vue中key的作用和工作原理，说说你对它的理解")])]),e._v(" "),t("div",{staticClass:"language-\\ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.key的作用主要是为了高效的更新虚拟DOM，期中vue在path过程中通过key可以精准判断两个节点是否是同一个\n从而避免频繁更新不同元素，使得整个path过程更加高效，减少DOM操作，提高性能\n")])])]),t("p",[t("strong",[e._v("23.vue打包后页面空白问题")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("publicPath:'/   =>./\n\nl路由模式\n\thash  \n\thistory\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);